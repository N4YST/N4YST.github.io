<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Nayst"><meta name="copyright" content="Nayst"><meta name="generator" content="Hexo 6.2.0"><meta name="theme" content="hexo-theme-yun"><title>Vue | Nayst-Blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/images/Doge.svg"><link rel="mask-icon" href="/images/Doge.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"www.nayst.top","root":"/","title":["Nayst","的","小","站"],"version":"1.10.6","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="简介Vue - 介绍Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 后起之秀，生态完善，已然称为前端工">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue">
<meta property="og:url" content="https://www.nayst.top/2021/10/30/Vue/index.html">
<meta property="og:site_name" content="Nayst-Blog">
<meta property="og:description" content="简介Vue - 介绍Vue (读音 &#x2F;vjuː&#x2F;，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 后起之秀，生态完善，已然称为前端工">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/MVVM.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/lifecycle.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/lifecyclefunc.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/image-20220103170359406.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/components.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/transition.png">
<meta property="og:image" content="https://www.nayst.top/2021/10/30/Vue/vuex.png">
<meta property="article:published_time" content="2021-10-30T03:06:22.000Z">
<meta property="article:modified_time" content="2022-09-16T02:38:16.713Z">
<meta property="article:author" content="Nayst">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.nayst.top/2021/10/30/Vue/MVVM.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Nayst"><img width="96" loading="lazy" src="/images/kakashi.png" alt="Nayst"><span class="site-author-status" title="努力做一个对社会有贡献的人">🤣</span></a><div class="site-author-name"><a href="/about/">Nayst</a></div><span class="site-name">Nayst-Blog</span><sub class="site-subtitle">远离舒适圈</sub><div class="site-description">已入江湖，未配良剑</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">20</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" title="2495582918" target="_blank" style="color:#007722"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" title="y1049843745" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/N4YST" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><span class="icon iconify" data-icon="ri:weibo-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=277777144" title="网易云音乐" target="_blank" style="color:#C20C0C"><span class="icon iconify" data-icon="ri:netease-cloud-music-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a><a class="links-item hty-icon-button" href="/girls/" title="我的老婆们" style="color:pink"><span class="icon iconify" data-icon="ri:women-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">Vue - 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">Vue - 特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E6%96%87%E6%A1%A3"><span class="toc-number">1.3.</span> <span class="toc-text">Vue - 文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-MVVM%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">Vue - MVVM模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%BC%95%E5%85%A5"><span class="toc-number">1.5.</span> <span class="toc-text">Vue - 引入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Vue-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">实例 - 创建一个 Vue 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">实例 - 数据与方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">2.3.</span> <span class="toc-text">实例 - 生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA"><span class="toc-number">2.4.</span> <span class="toc-text">实例 - 生命周期图示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-%E6%8F%92%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">模板语法 - 插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">模板语法 - 指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">4.</span> <span class="toc-text">数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">4.1.</span> <span class="toc-text">数据 - 单向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">4.2.</span> <span class="toc-text">数据 - 双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.</span> <span class="toc-text">数据 - 表单输入数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">数据 - 数据代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">事件 - 事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">事件 - 事件修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.3.</span> <span class="toc-text">事件 - 键盘事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">属性 - 计算属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">属性 - 监视属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">7.</span> <span class="toc-text">绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Class%E6%A0%B7%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">绑定 - Class样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Style%E6%A0%B7%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">绑定 - Style样式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">8.</span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">8.1.</span> <span class="toc-text">渲染 - 条件渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">8.2.</span> <span class="toc-text">渲染 - 列表渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">9.</span> <span class="toc-text">生命周期钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-beforeCreate"><span class="toc-number">9.1.</span> <span class="toc-text">生命周期钩子 - beforeCreate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-created"><span class="toc-number">9.2.</span> <span class="toc-text">生命周期钩子 - created</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-beforeMount"><span class="toc-number">9.3.</span> <span class="toc-text">生命周期钩子 - beforeMount</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-mounted"><span class="toc-number">9.4.</span> <span class="toc-text">生命周期钩子 - mounted</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-beforeUpdate"><span class="toc-number">9.5.</span> <span class="toc-text">生命周期钩子 - beforeUpdate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-updated"><span class="toc-number">9.6.</span> <span class="toc-text">生命周期钩子 - updated</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-beforeDestroy"><span class="toc-number">9.7.</span> <span class="toc-text">生命周期钩子 - beforeDestroy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-destroyed"><span class="toc-number">9.8.</span> <span class="toc-text">生命周期钩子 - destroyed</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-number">10.</span> <span class="toc-text">脚手架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%89%8B%E6%9E%B6-%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">脚手架 - 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%AE%89%E8%A3%85"><span class="toc-number">10.2.</span> <span class="toc-text">脚手架 - 安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%89%8B%E6%9E%B6-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">脚手架 - 目录结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">11.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-%E5%9F%BA%E7%A1%80"><span class="toc-number">11.1.</span> <span class="toc-text">组件 - 基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">11.2.</span> <span class="toc-text">组件 - 非单文件组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">11.3.</span> <span class="toc-text">组件 - 单文件组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97"><span class="toc-number">11.4.</span> <span class="toc-text">组件 - 组件嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-ref"><span class="toc-number">11.5.</span> <span class="toc-text">组件 - ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-props"><span class="toc-number">11.6.</span> <span class="toc-text">组件 - props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-mixin"><span class="toc-number">11.7.</span> <span class="toc-text">组件 - mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-plugin"><span class="toc-number">11.8.</span> <span class="toc-text">组件 - plugin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-slot"><span class="toc-number">11.9.</span> <span class="toc-text">组件 - slot</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number">12.</span> <span class="toc-text">通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">12.1.</span> <span class="toc-text">通信 - 自定义事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">12.2.</span> <span class="toc-text">通信 - 全局事件总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">12.3.</span> <span class="toc-text">通信 - 消息订阅与发布</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">13.</span> <span class="toc-text">过渡动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB-%E5%8D%95%E7%BB%84%E4%BB%B6"><span class="toc-number">13.1.</span> <span class="toc-text">过渡动画 - 单组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB-%E7%B1%BB%E5%90%8D"><span class="toc-number">13.2.</span> <span class="toc-text">过渡动画 - 类名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E5%BA%A6%E5%8A%A8%E7%94%BB-JS-%E9%92%A9%E5%AD%90"><span class="toc-number">13.3.</span> <span class="toc-text">过度动画 - JS 钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB-%E5%A4%9A%E7%BB%84%E4%BB%B6"><span class="toc-number">13.4.</span> <span class="toc-text">过渡动画 - 多组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">13.5.</span> <span class="toc-text">过渡动画 - 第三方动画</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82"><span class="toc-number">14.</span> <span class="toc-text">数据请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-Axios"><span class="toc-number">14.1.</span> <span class="toc-text">数据请求 - Axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-%E4%BB%A3%E7%90%86"><span class="toc-number">14.2.</span> <span class="toc-text">数据请求 - 代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex"><span class="toc-number">15.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E7%AE%80%E4%BB%8B"><span class="toc-number">15.1.</span> <span class="toc-text">Vuex - 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E4%BD%BF%E7%94%A8"><span class="toc-number">15.2.</span> <span class="toc-text">Vuex - 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">15.3.</span> <span class="toc-text">Vuex - 原理图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-state"><span class="toc-number">15.4.</span> <span class="toc-text">Vuex - state</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-actions"><span class="toc-number">15.5.</span> <span class="toc-text">Vuex - actions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-mutations"><span class="toc-number">15.6.</span> <span class="toc-text">Vuex - mutations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-getters"><span class="toc-number">15.7.</span> <span class="toc-text">Vuex - getters</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">16.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E7%AE%80%E4%BB%8B"><span class="toc-number">16.1.</span> <span class="toc-text">路由 - 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E4%BD%BF%E7%94%A8"><span class="toc-number">16.2.</span> <span class="toc-text">路由 - 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E9%85%8D%E7%BD%AE"><span class="toc-number">16.3.</span> <span class="toc-text">路由 - 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E5%B5%8C%E5%A5%97"><span class="toc-number">16.4.</span> <span class="toc-text">路由 - 嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-number">16.5.</span> <span class="toc-text">路由 - 编程式导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E5%91%BD%E5%90%8D"><span class="toc-number">16.6.</span> <span class="toc-text">路由 - 命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">16.7.</span> <span class="toc-text">路由 - 重定向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E5%88%AB%E5%90%8D"><span class="toc-number">16.8.</span> <span class="toc-text">路由 - 别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-%E4%BC%A0%E5%8F%82"><span class="toc-number">16.9.</span> <span class="toc-text">路由 - 传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-history"><span class="toc-number">16.10.</span> <span class="toc-text">路由 - history</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://www.nayst.top/2021/10/30/Vue/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Nayst"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Nayst-Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Vue</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-10-30 11:06:22" itemprop="dateCreated datePublished" datetime="2021-10-30T11:06:22+08:00">2021-10-30</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2022-09-16 10:38:16" itemprop="dateModified" datetime="2022-09-16T10:38:16+08:00">2022-09-16</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><span class="icon iconify" data-icon="ri:file-word-line"></span></span> <span title="本文字数">10.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><span class="icon iconify" data-icon="ri:timer-line"></span></span> <span title="阅读时长">47m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%89%8D%E5%90%8E%E7%AB%AF/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">前后端</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AC%94%E8%AE%B0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">笔记</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Vue-介绍"><a href="#Vue-介绍" class="headerlink" title="Vue - 介绍"></a>Vue - 介绍</h2><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<p>后起之秀，生态完善，已然称为前端工程师必备技能。</p>
<h2 id="Vue-特点"><a href="#Vue-特点" class="headerlink" title="Vue - 特点"></a>Vue - 特点</h2><ol>
<li>声明式渲染</li>
<li>组件化模式</li>
<li>使用 虚拟 DOM + 优秀的 Diff 算法 ，高复用 DOM 节点</li>
</ol>
<h2 id="Vue-文档"><a href="#Vue-文档" class="headerlink" title="Vue - 文档"></a>Vue - 文档</h2><p><a target="_blank" rel="noopener" href="https://vuejs.org/">官方网站</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">中文文档</a></p>
<h2 id="Vue-MVVM模型"><a href="#Vue-MVVM模型" class="headerlink" title="Vue - MVVM模型"></a>Vue - MVVM模型</h2><p>虽然没有完全遵循 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVVM">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<ol>
<li><em>M</em> - 模型（Model）：对应 data 中的数据</li>
<li><em>V</em> - 视图（View）：对应模板</li>
<li><em>VM</em> - 视图模型（ViewModel）：对应 Vue 实例对象</li>
</ol>
<img src="/2021/10/30/Vue/MVVM.png" class="" loading="lazy">

<h2 id="Vue-引入"><a href="#Vue-引入" class="headerlink" title="Vue - 引入"></a>Vue - 引入</h2><ol>
<li><p>通过 &lt;script&gt; 标签引入<strong>远程</strong> Vue.js</p>
<ul>
<li>对于制作原型或学习，你可以这样使用最新版本：</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>

<ul>
<li>对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.6.14"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>

<ul>
<li>如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件：</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"module"</span><span class="token operator">></span>
  <span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>
</li>
<li><p>通过 &lt;script&gt; 标签引入<strong>本地</strong> Vue.js</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/js/vue.js">开发版本</a>包含完整的警告和调试模式</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/js/vue.min.js">生产版本</a>删除了警告，33.46KB min+gzip</p>
</li>
<li><p>使用 NPM 安装</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 最新稳定版</span>
$ <span class="token function">npm</span> <span class="token function">install</span> vue</code></pre></li>
</ol>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="实例-创建一个-Vue-实例"><a href="#实例-创建一个-Vue-实例" class="headerlink" title="实例 - 创建一个 Vue 实例"></a>实例 - 创建一个 Vue 实例</h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p>
<p><strong>注意</strong>：Vue 实例所管理的函数<strong>不能用箭头函数</strong>，否则 this 指向的不是当前 vm 而是 window</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">var vm &#x3D; new Vue(&#123;
  el:&#39;#root&#39;,
  data:&#123;
      name:&#39;nayst&#39;
  &#125;,
  methods:&#123;
      method1()&#123;
          
      &#125;
  &#125;,
  ...
&#125;)</code></pre>

<p><code>el</code> 还可以利用<code>$mount</code>挂载到 vm 上：</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">var vm &#x3D; new Vue(&#123;
	
&#125;)
vm.$mount(&#39;#root&#39;)</code></pre>

<p><code>data</code>除了上述的对象式写法，还有一种常用的函数式写法：</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">var vm &#x3D; new Vue(&#123;
	data() &#123;
        return &#123;
            name:&#39;test&#39;
        &#125;
    &#125;
&#125;)</code></pre>

<p>在组件中，<code>data</code>必须使用_函数式_写法！</p>
<h2 id="实例-数据与方法"><a href="#实例-数据与方法" class="headerlink" title="实例 - 数据与方法"></a>实例 - 数据与方法</h2><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 我们的数据对象</span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span>

<span class="token comment">// 该对象被加入到一个 Vue 实例中</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> data
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>

<span class="token comment">// 获得这个实例上的 property</span>
<span class="token comment">// 返回源数据中对应的字段</span>
vm<span class="token punctuation">.</span>a <span class="token operator">==</span> data<span class="token punctuation">.</span>a <span class="token comment">// => true</span>

<span class="token comment">// 设置 property 也会影响到原始数据</span>
vm<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>
data<span class="token punctuation">.</span>a <span class="token comment">// => 2</span>

<span class="token comment">// ……反之亦然</span>
data<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span>
vm<span class="token punctuation">.</span>a <span class="token comment">// => 3</span></code></pre>

<h2 id="实例-生命周期钩子"><a href="#实例-生命周期钩子" class="headerlink" title="实例 - 生命周期钩子"></a>实例 - 生命周期钩子</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>例如 <code>created</code>钩子可以用来在一个实例被创建之后执行代码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// `this` 指向 vm 实例</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a is: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// => "a is: 1"</span></code></pre>

<h2 id="实例-生命周期图示"><a href="#实例-生命周期图示" class="headerlink" title="实例 - 生命周期图示"></a>实例 - 生命周期图示</h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>
<img src="/2021/10/30/Vue/lifecycle.png" class="" loading="lazy">

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="模板语法-插值"><a href="#模板语法-插值" class="headerlink" title="模板语法 - 插值"></a>模板语法 - 插值</h2><p>插值语法用于解析标签体的内容，在双大括号之间加入 js 表达式。这种方式可以直接读取到<code>data</code>中的所有属性。</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</code></pre>

<p>对于所有的数据绑定，Vue.js 都提供了完全的 js 表达式支持。</p>
<pre class="language-vue" data-language="vue"><code class="language-vue">&#123;&#123; number + 1 &#125;&#125;

&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;

&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;

&lt;div v-bind:id&#x3D;&quot;&#39;list-&#39; + id&quot;&gt;&lt;&#x2F;div&gt;</code></pre>

<h2 id="模板语法-指令"><a href="#模板语法-指令" class="headerlink" title="模板语法 - 指令"></a>模板语法 - 指令</h2><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> 。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
<p>例如，给标签绑定<code>v-if</code>指令，通过改变<code>seen</code>值的真假来 插入&#x2F;移出 标签：</p>
<pre class="language-none"><code class="language-none">&lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</code></pre>

<p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p>
<pre class="language-none"><code class="language-none">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;
&lt;!-- 可以简写成下面的形式 --&gt;
&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</code></pre>

<p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p>
<pre class="language-none"><code class="language-none">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;
&lt;!-- 可以简写成下面的形式 --&gt;
&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</code></pre>

<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="数据-单向绑定"><a href="#数据-单向绑定" class="headerlink" title="数据 - 单向绑定"></a>数据 - 单向绑定</h2><p>通过<code>v-bind</code>完成对数据的单向绑定，数据只能从<code>data</code>流向页面。</p>
<pre class="language-none"><code class="language-none">&lt;div id&#x3D;&quot;root&quot;&gt;
    你原来的名字:&lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;name&quot;&gt;
&lt;&#x2F;div&gt;</code></pre>

<h2 id="数据-双向绑定"><a href="#数据-双向绑定" class="headerlink" title="数据 - 双向绑定"></a>数据 - 双向绑定</h2><p>通过<code>v-model</code>完成对数据的双向绑定，数据可以从<code>data</code>流向页面，也可以从页面流向<code>data</code>。</p>
<pre class="language-none"><code class="language-none">&lt;div id&#x3D;&quot;root&quot;&gt;
    你要修改的名字:&lt;input type&#x3D;&quot;text&quot; v-model:value&#x3D;&quot;name&quot;&gt;
&lt;&#x2F;div&gt;</code></pre>

<p>注意：（1）双向绑定一般都应用在表单类元素上。</p>
<p> （2）v-model:value 可以简写为 v-model ，因为 v-model 默认接收 value</p>
<h2 id="数据-表单输入数据"><a href="#数据-表单输入数据" class="headerlink" title="数据 - 表单输入数据"></a>数据 - 表单输入数据</h2><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。</p>
<p>在<strong>文本框、多行文本、下拉框</strong>中，在 data 中绑定 value 即可：</p>
<pre class="language-none"><code class="language-none">&lt;form @submit.prevent&#x3D;&quot;demo&quot;&gt;
    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;info.text&quot;&gt;
&lt;&#x2F;form&gt;</code></pre>

<p>在<strong>单选框</strong>中，需要绑定值，还要给标签配置 value ：</p>
<pre class="language-none"><code class="language-none">&lt;form @submit.prevent&#x3D;&quot;demo&quot;&gt;
    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;info.sex&quot; value&#x3D;&quot;male&quot;&gt;man
    &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; v-model&#x3D;&quot;info.sex&quot; value&#x3D;&quot;famale&quot;&gt;woman
&lt;&#x2F;form&gt;</code></pre>

<p>在<strong>复选框</strong>中，需要绑定值，还要给标签配置 value ，绑定的值要为一个_数组_：</p>
<pre class="language-none"><code class="language-none">&lt;form @submit.prevent&#x3D;&quot;demo&quot;&gt;
    &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;info.hobby&quot; value&#x3D;&quot;sing&quot;&gt;sing
    &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;info.hobby&quot; value&#x3D;&quot;dance&quot;&gt;dance
    &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;info.hobby&quot; value&#x3D;&quot;study&quot;&gt;study
&lt;&#x2F;form&gt;</code></pre>

<p>需要配置的 data ：</p>
<pre class="language-none"><code class="language-none">data:&#123;
    info:&#123;
    	text:&#39;&#39;,
        sex:&#39;famale&#39;,
        hobby:[]
    &#125;
&#125;</code></pre>

<h2 id="数据-数据代理"><a href="#数据-数据代理" class="headerlink" title="数据 - 数据代理"></a>数据 - 数据代理</h2><p>利用<code>Object.defineProperty(obj, prop, desc)</code> 操作数据，可以直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。</p>
<ul>
<li><p>obj：需要定义属性的当前对象</p>
</li>
<li><p>prop：当前需要定义的属性名</p>
</li>
<li><p>desc：属性描述符</p>
</li>
</ul>
<p>基本用法：</p>
<pre class="language-none"><code class="language-none">let Person &#x3D; &#123;
    name:&#39;&#39;,
&#125;
Object.defineProperty(Person, &#39;name&#39;, &#123;
    value: &#39;jack&#39;,
    enumberable:true,&#x2F;&#x2F;是否可以枚举,默认为false
    writable: true,&#x2F;&#x2F; 是否可以改变,默认为false
    configurable: true,&#x2F;&#x2F;是否可以被删除,默认为false
&#125;)</code></pre>

<p>进阶用法：</p>
<pre class="language-none"><code class="language-none">let Person &#x3D; &#123;
    name:&#39;&#39;,
    age:&#39;&#39;,
&#125;
let number &#x3D; 19
Object.defineProperty(Person, &#39;age&#39;, &#123;
    get()&#123;
        return number
    &#125;,
    set(value)&#123;
        number &#x3D; value
    &#125;
&#125;</code></pre>

<blockquote>
<p>Vue 中的数据代理，是通过 vm 对象来代理 data 对象中的属性的操作（读&#x2F;写）</p>
<p>Vue 中的数据代理的好处：更加方便的操作 data 中的数据</p>
<p>基本原理：通过 <code>Object.defineProperty</code> 把对象中的所有属性加到 vm 上，每一个属性都添加了对应的 getter&#x2F;setter ，用于操作 data 中对应的属性</p>
</blockquote>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件-事件处理"><a href="#事件-事件处理" class="headerlink" title="事件 - 事件处理"></a>事件 - 事件处理</h2><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行对应的代码。</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;buttom @click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;buttom&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">methods:&#123;
    greet()&#123;
        alert(&#39;Hello&#39;)
    &#125;
&#125;</code></pre>

<blockquote>
<ul>
<li><p>事件的回调需要配置在 methods 中，最终在 vm 上</p>
</li>
<li><p>methods 中配置的函数，不能用箭头函数，否则 this 就不是 vm 了</p>
</li>
<li><p>methods 中配置的函数，都是被 Vue 所管理的函数，this 指向的是 vm 或 组件实例对象</p>
</li>
</ul>
</blockquote>
<h2 id="事件-事件修饰符"><a href="#事件-事件修饰符" class="headerlink" title="事件 - 事件修饰符"></a>事件 - 事件修饰符</h2><p>Vue.js 为 <code>v-on</code> 提供如下了<strong>事件修饰符</strong>，用于在处理事件时进行一些限制。</p>
<ol>
<li>prevent：阻止默认事件（常用）</li>
<li>stop：阻止事件冒泡（常用）</li>
<li>once：事件只触发一次（常用）</li>
<li>capture：使用事件的捕获模式，即内部元素触发的事件优先在此处理，然后才交由内部元素进行处理</li>
<li>self：只有 event.target 是当前操作的元素时才触发事件，即事件不是从内部元素触发的</li>
<li>passive：事件的默认行为立即执行，无需等待事件回调执行完毕</li>
</ol>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; @click.prevent&#x3D;&quot;showInfo&quot;&gt;点我提示&lt;&#x2F;a&gt;
    &lt;!-- 修饰符可以串联 --&gt;
	&lt;a @click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;div&gt;</code></pre>

<h2 id="事件-键盘事件"><a href="#事件-键盘事件" class="headerlink" title="事件 - 键盘事件"></a>事件 - 键盘事件</h2><p>Vue.js 中的键盘事件有 <code>keyup</code>（按下并抬起时触发）和 <code>keydown</code> （按下时触发），并且可以在触发时添加修饰符：_enter_（回车）、_delete_（删除）、_esc_（退出）、_space_（空格）、_tab_（换行）、_up_（上）、_down_（下）、_left_（左）、_down_（右）。</p>
<p>其余未提供别名的按键，可以使用按键原始的 key 值去绑定，利用 <strong>event.keyCode</strong> 获取按键编码。</p>
<p>系统修饰键 Ctrl、Alt、Shift、Meta 用法特殊，当搭配 keydown 使用的时候，正常按下即触发；当搭配 keyup 的时候，需要按下修饰键时同时按下任意其他键，释放后触发。</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;按下回车提示输入&quot; @keydown.ctrl&#x3D;&quot;showInfo&quot;&gt;
&lt;&#x2F;div&gt;</code></pre>

<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="属性-计算属性"><a href="#属性-计算属性" class="headerlink" title="属性 - 计算属性"></a>属性 - 计算属性</h2><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。 Vue.js 中提供了_计算属性_，用于得到不存在的属性。例如：</p>
<pre class="language-none"><code class="language-none">&lt;div id&#x3D;&quot;root&quot;&gt;
    你的全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;span&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    firstName:&#39;nayst&#39;,
    lastName:&#39;yang&#39;
&#125;
computed:&#123;
    fullName:&#123;
        &#x2F;&#x2F;当 fullName 被 读取 时调用 get
        get()&#123;
            console.log(&#39;get被调用了&#39;,this)
            return this.firstName + &#39;-&#39; + this.lastName
		&#125;,
        &#x2F;&#x2F;当 fullName 被 修改 时调用 set
        set(value)&#123;
            console.log(&#39;set&#39;,value)
        &#125;
    &#125;
&#125;</code></pre>

<p>当计算属性不需要<code>setter</code>修改时，可以简写成如下形式：</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;计算属性的简写
computed:&#123;
    fullName()&#123;
        console.log(&#39;get被调用了&#39;,this)
        return this.firstName + &#39;-&#39; + this.lastName
    &#125;
&#125;</code></pre>

<p>原理：底层借助了<code>Object.defineProperty</code>方法提供的 setter 和 getter</p>
<h2 id="属性-监视属性"><a href="#属性-监视属性" class="headerlink" title="属性 - 监视属性"></a>属性 - 监视属性</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>监视属性</strong>。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。例如：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;请输入您的问题&quot; v-model&#x3D;&quot;question&quot;&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
	question:&#39;&#39;
&#125;,
watch:&#123;
    answer:&#123;
        immediate:true,&#x2F;&#x2F;在初始化时调用一次 handler
        &#x2F;&#x2F; handler 在 answer 改变时调用
		handler(newValue,oldValue)&#123;
            console.log(&#39;question被修改了，原来是&#39;,oldValue,&#39;，现在是&#39;,newValue)
        &#125;
    &#125;
&#125;</code></pre>

<p>还有另一种命令式的 API 写法：</p>
<pre class="language-none"><code class="language-none">vm.$watch(&#39;answer&#39;,&#123;
    handler(newValue,oldValue)&#123;
        console.log(&#39;question被修改了，原来是&#39;,oldValue,&#39;，现在是&#39;,newValue)
    &#125;
&#125;)</code></pre>

<p>当需要监视对_多级结构_中某个属性变化时，需要开启<strong>深度监视</strong>：</p>
<pre class="language-none"><code class="language-none">data:&#123;
	numbers:&#123;
        a:1,
        b:2
    &#125;
&#125;,
watch:&#123;
    numbers:&#123;
        deep:true&#x2F;&#x2F;是否开启深度监视
		handler(Value)&#123;
            console.log(&#39;question被修改了&#39;,Value)
        &#125;
    &#125;
&#125;</code></pre>

<p>当_监视属性_中只需要 handler 时，可以采用如下简写形式：</p>
<pre class="language-none"><code class="language-none">watch:&#123;
    answer(newValue,oldValue)&#123;
        console.log(&#39;question被修改了，原来是&#39;,oldValue,&#39;，现在是&#39;,newValue)
    &#125;
&#125;</code></pre>

<p>当然 API 写法也是可以简写的：</p>
<pre class="language-none"><code class="language-none">vm.$watch(&#39;answer&#39;,function(newValue,oldValue)&#123;
	console.log(&#39;question被修改了，原来是&#39;,oldValue,&#39;，现在是&#39;,newValue)
&#125;)</code></pre>

<h1 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h1><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组</p>
<h2 id="绑定-Class样式"><a href="#绑定-Class样式" class="headerlink" title="绑定 - Class样式"></a>绑定 - Class样式</h2><p>我们可以传给 <code>v-bind:class</code> 一个字符串，以动态地切换 class：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;class&quot;&gt;
        &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    msg:&#39;This is a test.&#39;,
    class:&#39;className&#39;
&#125;</code></pre>

<p>同样的，我们也可以传_数组_和_对象_：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;classArr&quot;&gt;
        &lt;span&gt;&#123;&#123; msg1 &#125;&#125;&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
    &lt;div class&#x3D;&quot;basic&quot; :class&#x3D;&quot;classObj&quot;&gt;
        &lt;span&gt;&#123;&#123; msg2 &#125;&#125;&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    msg1:&#39;This is an array.&#39;,
    msg2:&#39;This is an object&#39;,
    classArr:[&#39;className1&#39;,&#39;className2&#39;,&#39;className3&#39;],
    classObj:&#123;
        className1:true,
        className2:false,
        className3:true
    &#125;
&#125;</code></pre>

<h2 id="绑定-Style样式"><a href="#绑定-Style样式" class="headerlink" title="绑定 - Style样式"></a>绑定 - Style样式</h2><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;styleObj&quot;&gt;
        &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    msg:&#39;This is an object.&#39;,
    styleObj:&#123;
        fontsize: &#39;40px&#39;,
        color: &#39;red&#39;
    &#125;
&#125;</code></pre>

<p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div class&#x3D;&quot;basic&quot; :style&#x3D;&quot;styleArr&quot;&gt;
        &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    msg:&#39;This is an array.&#39;,
    styleObj:[
        &#123;
            fontsize: &#39;40px&#39;,
        	color: &#39;red&#39;
        &#125;,
        &#123;
            backgroundColor: &#39;gray&#39;
        &#125;
    ]
&#125;</code></pre>

<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1><h2 id="渲染-条件渲染"><a href="#渲染-条件渲染" class="headerlink" title="渲染 - 条件渲染"></a>渲染 - 条件渲染</h2><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染。<code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用。<code>v-else</code> 指令用于表示 <code>v-if</code> 的“else 块”</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div v-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;1&quot;&gt;Angular&lt;&#x2F;div&gt;
    &lt;div v-else-if&#x3D;&quot;n&#x3D;&#x3D;&#x3D;2&quot;&gt;Vue&lt;&#x2F;div&gt;
    &lt;div v-else&gt;Wrong choice!&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>

<p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p>
<pre class="language-none"><code class="language-none">&lt;div&gt;
    &lt;div v-show&#x3D;&quot;false&quot;&gt;You can&#39;t see me&lt;&#x2F;div&gt;
    &lt;div v-show&#x3D;&quot;true&quot;&gt;You can see me&lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;</code></pre>

<h2 id="渲染-列表渲染"><a href="#渲染-列表渲染" class="headerlink" title="渲染 - 列表渲染"></a>渲染 - 列表渲染</h2><p>我们可以用 <code>v-for</code> 指令基于一个_数组_来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong></p>
<pre class="language-none"><code class="language-none">&lt;ul&gt;
    &lt;li v-for&#x3D;&quot;(person,index) in persons&quot; :key&#x3D;&quot;index&quot;&gt;
    	&#123;&#123;person.name&#125;&#125;-&#123;&#123;person.age&#125;&#125;
    &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    persons:[
        &#123;id:&#39;01&#39;,name:&#39;Akko&#39;,age:&#39;18&#39;&#125;,
        &#123;id:&#39;02&#39;,name:&#39;Ashe&#39;,age:&#39;19&#39;&#125;,
        &#123;id:&#39;03&#39;,name:&#39;Luxa&#39;,age:&#39;20&#39;&#125;
    ]
&#125;</code></pre>

<p>你也可以用 <code>v-for</code> 来遍历一个_对象_的 property</p>
<pre class="language-none"><code class="language-none">&lt;ul&gt;
    &lt;li v-for&#x3D;&quot;(value,key) in cars&quot; :key&#x3D;&quot;key&quot;&gt;
    	&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;
    &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;</code></pre>
<pre class="language-none"><code class="language-none">data:&#123;
    cars:&#123;
        name:&#39;奥迪A8&#39;,
        price:&#39;800k&#39;,
        color:&#39;black&#39;
    &#125;
&#125;</code></pre>

<p><strong>注意</strong>：key 在循环中作为_唯一标识_，不写默认为_循环的索引_</p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><p>所有生命周期钩子的 <code>this</code> 上下文将自动绑定至实例中，因此你可以访问 data、computed 和 methods。这意味着<strong>你不应该使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。因为箭头函数绑定了父级上下文，所以 <code>this</code> 不会指向预期的组件实例，并且<code>this.fetchTodos</code> 将会是 undefined。</p>
<img src="/2021/10/30/Vue/lifecyclefunc.png" class="" loading="lazy">

<h2 id="生命周期钩子-beforeCreate"><a href="#生命周期钩子-beforeCreate" class="headerlink" title="生命周期钩子 - beforeCreate"></a>生命周期钩子 - beforeCreate</h2><p>在实例初始化之后,进行数据侦听和事件&#x2F;侦听器的配置之前同步调用</p>
<h2 id="生命周期钩子-created"><a href="#生命周期钩子-created" class="headerlink" title="生命周期钩子 - created"></a>生命周期钩子 - created</h2><p>在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件&#x2F;侦听器的回调函数。然而，挂载阶段还没开始，且 <code>$el</code> property 目前尚不可用</p>
<h2 id="生命周期钩子-beforeMount"><a href="#生命周期钩子-beforeMount" class="headerlink" title="生命周期钩子 - beforeMount"></a>生命周期钩子 - beforeMount</h2><p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用</p>
<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h2 id="生命周期钩子-mounted"><a href="#生命周期钩子-mounted" class="headerlink" title="生命周期钩子 - mounted"></a>生命周期钩子 - mounted</h2><p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内</p>
<p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 <code>mounted</code> 内部使用 <em>vm.$nextTick</em></p>
<pre class="language-none"><code class="language-none">mounted()&#123;
  this.$nextTick(function () &#123;
    &#x2F;&#x2F; 仅在整个视图都被渲染之后才会运行的代码
  &#125;)
&#125;</code></pre>

<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h2 id="生命周期钩子-beforeUpdate"><a href="#生命周期钩子-beforeUpdate" class="headerlink" title="生命周期钩子 - beforeUpdate"></a>生命周期钩子 - beforeUpdate</h2><p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行</strong></p>
<h2 id="生命周期钩子-updated"><a href="#生命周期钩子-updated" class="headerlink" title="生命周期钩子 - updated"></a>生命周期钩子 - updated</h2><p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#computed">计算属性</a>或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#watch">watcher</a> 取而代之。</p>
<p>注意，<code>updated</code> <strong>不会</strong>保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 <code>updated</code> 里使用 <em>vm.$nextTick</em></p>
<pre class="language-none"><code class="language-none">updated()&#123;
  this.$nextTick(function () &#123;
    &#x2F;&#x2F;  仅在整个视图都被重新渲染之后才会运行的代码     
  &#125;)
&#125;</code></pre>

<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h2 id="生命周期钩子-beforeDestroy"><a href="#生命周期钩子-beforeDestroy" class="headerlink" title="生命周期钩子 - beforeDestroy"></a>生命周期钩子 - beforeDestroy</h2><p>实例销毁之前调用。在这一步，实例仍然完全可用</p>
<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h2 id="生命周期钩子-destroyed"><a href="#生命周期钩子-destroyed" class="headerlink" title="生命周期钩子 - destroyed"></a>生命周期钩子 - destroyed</h2><p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</p>
<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>
<h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><h2 id="脚手架-简介"><a href="#脚手架-简介" class="headerlink" title="脚手架 - 简介"></a>脚手架 - 简介</h2><p>Vue CLI (_C_ommand _L_ine _I_nterface)是一个基于 Vue.js 进行快速开发的完整系统，提供：</p>
<ul>
<li>通过 <code>@vue/cli</code> 实现的交互式的项目脚手架</li>
<li>通过 <code>@vue/cli</code> + <code>@vue/cli-service-global</code> 实现的零配置原型开发</li>
<li>一个运行时依赖 (<em>@vue&#x2F;cli-service</em>)，该依赖：<ul>
<li>可升级；</li>
<li>基于 webpack 构建，并带有合理的默认配置；</li>
<li>可以通过项目内的配置文件进行配置；</li>
<li>可以通过插件进行扩展</li>
</ul>
</li>
<li>一个丰富的官方插件集合，集成了前端生态中最好的工具</li>
<li>一套完全图形化的创建和管理 Vue.js 项目的用户界面</li>
</ul>
<p>Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject</p>
<h2 id="脚手架-安装"><a href="#脚手架-安装" class="headerlink" title="脚手架 - 安装"></a>脚手架 - 安装</h2><ol>
<li><p>全局安装 @vue&#x2F;cli （仅首次）</p>
<pre class="language-none"><code class="language-none">npm install -g @vue&#x2F;cli</code></pre>
</li>
<li><p>切换到你要创建项目的目录，创建项目</p>
<pre class="language-none"><code class="language-none">vue create xxxx</code></pre>
</li>
<li><p>启动项目</p>
<pre class="language-none"><code class="language-none">npm run serve</code></pre></li>
</ol>
<p><strong>备注</strong>：切换淘宝镜像</p>
<pre class="language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre>

<h2 id="脚手架-目录结构"><a href="#脚手架-目录结构" class="headerlink" title="脚手架 - 目录结构"></a>脚手架 - 目录结构</h2><img src="/2021/10/30/Vue/image-20220103170359406.png" class="" loading="lazy">

<ol>
<li><p>文件</p>
<p><code>.gitnore</code>： Git 的忽略文件，在此描述哪些文件（夹）不接受 Git 的管理</p>
<p><code>babel.config.js</code>：babel 的控制文件</p>
<p><code>package.json</code>：包的说明书，存在于 npm 创建的工程中</p>
<p><code>package-lock.json</code>：包版本控制文件，版本仓库</p>
<p><code>README.md</code>：项目的描述文件</p>
</li>
<li><p>文件夹</p>
<p><code>src</code>：存放以下内容</p>
<p>——<code>main.js</code>：整个项目的入口文件</p>
<p>——<code>App.vue</code>：页面的主要内容</p>
<p>——<code>asserts</code>：存放项目里的静态资源，如图片、页签</p>
<p>——<code>components</code>：存放组件</p>
<p><code>public</code>：存放公共资源</p>
</li>
</ol>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件-基础"><a href="#组件-基础" class="headerlink" title="组件 - 基础"></a>组件 - 基础</h2><p>组件是可复用的 Vue 实例，且带有一个名字</p>
<p><strong>注意</strong>：<strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝</p>
<p>通常一个应用会以一棵嵌套的组件树的形式来组织：</p>
<img src="/2021/10/30/Vue/components.png" class="" loading="lazy">

<h2 id="组件-非单文件组件"><a href="#组件-非单文件组件" class="headerlink" title="组件 - 非单文件组件"></a>组件 - 非单文件组件</h2><p>使用组件的步骤：</p>
<ol>
<li><p>定义（创建）组件</p>
<p>使用 Vue.extend(options) 创建，其中的 options 和创建 Vue 实例时的 options 几乎一样</p>
</li>
<li><p>注册组件</p>
<ul>
<li>局部注册：在创建 Vue 实例的时候传入 components 选项</li>
<li>全局注册：直接 Vue.component(‘组件名’,组件)</li>
</ul>
</li>
<li><p>使用组件</p>
<p>编写组件标签：&lt;组件名&#x2F;&gt;</p>
</li>
</ol>
<pre class="language-none"><code class="language-none">&lt;!-- 准备一个容器 --&gt;
&lt;div id&#x3D;&quot;root&quot;&gt;
    &lt;school&gt;&lt;&#x2F;school&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">const school &#x3D; Vue.extend(&#123;
    template:&#96;&lt;div&gt;&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&#96;,
    data()&#123;
        return&#123;
            name:&#39;CCSU&#39;
        &#125;
    &#125;
&#125;)

new Vue(&#123;
    el:&#39;#root&#39;,
    components:&#123;school&#125;
&#125;)</code></pre>

<p><strong>注意</strong>：</p>
<ol>
<li>组件名是多单词时，中间用<code>-</code>连接，如果在脚手架中，首字母大写即可</li>
<li>组件标签的自闭合只能在脚手架中用</li>
</ol>
<h2 id="组件-单文件组件"><a href="#组件-单文件组件" class="headerlink" title="组件 - 单文件组件"></a>组件 - 单文件组件</h2><p>将非单文件组件的内容写作一个独立的<code>.vue</code>文件，在脚手架中使用</p>
<pre class="language-none"><code class="language-none">&lt;template&gt;
	&lt;div&gt;
        
    &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;

&lt;script&gt;
	export default &#123;
        name:&#39;filename&#39;,
        data()&#123;
            return&#123;
                
            &#125;
        &#125;,
        methods:&#123;
            
        &#125;
    &#125;
&lt;&#x2F;script&gt;

&lt;style&gt;&lt;&#x2F;style&gt;</code></pre>

<p><strong>注意</strong>：这里的<code>filename</code>必须与组件名保持一直，首字母大写</p>
<h2 id="组件-组件嵌套"><a href="#组件-组件嵌套" class="headerlink" title="组件 - 组件嵌套"></a>组件 - 组件嵌套</h2><p>Vue 支持在组件中注册子组件</p>
<pre class="language-none"><code class="language-none">&lt;!-- 准备一个容器 --&gt;
&lt;div id&#x3D;&quot;root&quot;&gt;
    &lt;school&gt;&lt;&#x2F;school&gt;
&lt;&#x2F;div&gt;</code></pre>
<pre class="language-none"><code class="language-none">const student &#x3D; Vue.extend(&#123;
    template:&#96;&lt;div&gt;&lt;h2&gt;学生名称：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&#96;,
    data()&#123;
        return&#123;
            name:&#39;Nayst&#39;
        &#125;
    &#125;
&#125;);

const school &#x3D; Vue.extend(&#123;
    template:&#96;
    	&lt;div&gt;&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;
    	&lt;student&gt;&lt;&#x2F;student&gt;
    &#96;,
    data()&#123;
        return&#123;
            name:&#39;CCSU&#39;
        &#125;
    &#125;
&#125;);

new Vue(&#123;
    el:&#39;#root&#39;,
    components:&#123;school&#125;
&#125;);</code></pre>

<h2 id="组件-ref"><a href="#组件-ref" class="headerlink" title="组件 - ref"></a>组件 - ref</h2><p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。</p>
<p><strong>$refs</strong>是一个对象，存放注册过 <code>ref</code> attribute 的所有 DOM 元素和组件实例</p>
<blockquote>
<p>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素</p>
<p>如果用在子组件上，引用就指向组件实例（vc）</p>
</blockquote>
<h2 id="组件-props"><a href="#组件-props" class="headerlink" title="组件 - props"></a>组件 - props</h2><p>功能：让组件接受外部传过来的数据</p>
<p>传递数据：直接在标签内部写</p>
<pre class="language-none"><code class="language-none">&lt;Student name&#x3D;&quot;nayst&quot; age&#x3D;&quot;21&quot;&#x2F;&gt;</code></pre>

<p>接收数据：在组件内的 props 配置项内配置</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;第一种：只接收数据
props:[&#39;name&#39;,&#39;age&#39;]
&#x2F;&#x2F;第二种：限制类型
props:&#123;
    name:String,
    age:Number
&#125;
&#x2F;&#x2F;第三种：限制类型、限制必要性、指定默认值，完整写法
props:&#123;
    name:&#123;
        type:String,
        required:true,
        default:&#39;nayst&#39;
    &#125;,
    age:&#123;
        type:Number,
        required:false,
        default:&#39;18&#39;
    &#125;
&#125;</code></pre>

<p><strong>注意</strong>：props 是只读的，Vue 底层会监测你对 props 的修改，并且在修改后发出警告</p>
<h2 id="组件-mixin"><a href="#组件-mixin" class="headerlink" title="组件 - mixin"></a>组件 - mixin</h2><p>功能：可以把多个文件共用的配置提取成一个混入对象</p>
<p>在 src 中创建 <code>mixins.js</code> （名字随意），用于定义混入：</p>
<pre class="language-none"><code class="language-none">export const test &#x3D; &#123;
    data()&#123;
        
    &#125;,
    methods:&#123;
        
    &#125;
&#125;</code></pre>

<p>局部引入：在组件中引入并使用：</p>
<pre class="language-none"><code class="language-none">import &#123;test&#125; from &#39;..&#x2F;mixin&#39;
export default &#123;
    name:&#39;Student&#39;,
    mixins:[test]
&#125;</code></pre>

<p>全局引入：在<code>main.js</code>中引入：</p>
<pre class="language-none"><code class="language-none">import &#123;test&#125; from &#39;.&#x2F;mixin&#39;
Vue.mixin(test)</code></pre>

<h2 id="组件-plugin"><a href="#组件-plugin" class="headerlink" title="组件 - plugin"></a>组件 - plugin</h2><p>功能：用于增强 Vue，本质是包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据</p>
<p>在 src 中创建 <code>plugins.js</code> （名字随意），用于定义插件：</p>
<pre class="language-none"><code class="language-none">export default &#123;
    install(Vue)&#123;
        Vue.filter()&#x2F;&#x2F;定义全局过滤器
        Vue.directive()&#x2F;&#x2F;定义全局指令
        Vue.mixin()&#x2F;&#x2F;定义混入
        Vue.prototype.func &#x3D; ()&#x3D;&gt;&#123;&#125;&#x2F;&#x2F;在 Vue 原型上添加一个方法
    &#125;
&#125;</code></pre>

<p>在<code>main.js</code>中引入并使用插件：</p>
<pre class="language-none"><code class="language-none">import plugins from &#39;.&#x2F;plugins&#39;
Vue.use(plugins)</code></pre>

<h2 id="组件-slot"><a href="#组件-slot" class="headerlink" title="组件 - slot"></a>组件 - slot</h2><p>功能：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间的通信方式，适用于父组件给子组件传。</p>
<ol>
<li><p>默认插槽</p>
<p>父组件：</p>
<pre class="language-none"><code class="language-none">&lt;component&gt;
	&lt;div&gt;
        ...
    &lt;&#x2F;div&gt;
&lt;&#x2F;component&gt;</code></pre>

<p>子组件：</p>
<pre class="language-none"><code class="language-none">&lt;template&gt;
	&lt;div&gt;
    	&lt;!-- 定义插槽 --&gt;
    	&lt;slot&gt;默认内容&lt;&#x2F;slot&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;</code></pre>
</li>
<li><p>具名插槽</p>
<p>父组件：</p>
<pre class="language-none"><code class="language-none">&lt;component&gt;
    &lt;template slot&#x3D;&quot;header&quot;&gt;
    	&lt;div&gt;Header&lt;&#x2F;div&gt;
    &lt;&#x2F;template&gt;
    &lt;template slot&#x3D;&quot;footer&quot;&gt;
        &lt;div&gt;Footer&lt;&#x2F;div&gt;
    &lt;&#x2F;template&gt;
&lt;&#x2F;component&gt;</code></pre>

<p>子组件：</p>
<pre class="language-none"><code class="language-none">&lt;template&gt;
	&lt;div&gt;
        &lt;slot name&#x3D;&quot;footer&quot;&gt;Default footer&lt;&#x2F;slot&gt;
        &lt;slot name&#x3D;&quot;header&quot;&gt;Default header&lt;&#x2F;slot&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;template&gt;</code></pre>
</li>
<li><p>作用域插槽：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</p>
</li>
</ol>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="通信-自定义事件"><a href="#通信-自定义事件" class="headerlink" title="通信 - 自定义事件"></a>通信 - 自定义事件</h2><p>自定义事件，适用于<strong>子组件给父组件传递数据</strong></p>
<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称</p>
<p>第一步：定义一个自定义事件</p>
<pre class="language-none"><code class="language-none">methods:&#123;
	demo(value)&#123;
		console.log(&#39;自定义事件被调用了，收到了&#39;,value)
	&#125;
&#125;</code></pre>

<p>第二步：给子组件绑定自定义事件</p>
<pre class="language-none"><code class="language-none">&lt;Student @myEvent&#x3D;&quot;demo&quot;&#x2F;&gt;</code></pre>

<p>第三步：在子组件内触发自定义事件</p>
<pre class="language-none"><code class="language-none">&lt;button @click&#x3D;&quot;$emit(&#39;myEvent&#39;,value)&quot;&gt;&lt;&#x2F;button&gt;</code></pre>

<h2 id="通信-全局事件总线"><a href="#通信-全局事件总线" class="headerlink" title="通信 - 全局事件总线"></a>通信 - 全局事件总线</h2><p>全局事件总线（Global Event Bus），适用于<strong>任意组件</strong>间通信</p>
<p>第一步，安装全局事件总线</p>
<pre class="language-none"><code class="language-none">new Vue(&#123;
    beforeCreate() &#123;
        Vue.prototype.$bus &#x3D; this &#x2F;&#x2F;$bus 就是当前的应用
    &#125;
&#125;)</code></pre>

<p>第二步，利用事件总线发送数据</p>
<pre class="language-none"><code class="language-none">&lt;button @click&#x3D;&quot;$bus.$emit(&#39;test&#39;,studentName)&quot;&gt;&lt;&#x2F;button&gt;</code></pre>

<p>第三步，利用事件总线接收数据</p>
<pre class="language-none"><code class="language-none">mounted() &#123;
    this.$bus.$on(&#39;test&#39;,(data)&#x3D;&gt;&#123;
        
    &#125;)
&#125;,
beforeDestroy() &#123;
    this.$bus.$off(&#39;test&#39;)
&#125; </code></pre>

<p><strong>注意</strong>：最好在 <em>beforeDestroy</em> 钩子中，用<code>$off</code>去解绑当前组件用到的事件</p>
<h2 id="通信-消息订阅与发布"><a href="#通信-消息订阅与发布" class="headerlink" title="通信 - 消息订阅与发布"></a>通信 - 消息订阅与发布</h2><p>消息订阅与发布（pubsub），适用于<strong>任意组件</strong>间通信</p>
<p>第一步：安装<code>pubsub</code></p>
<pre class="language-none"><code class="language-none">npm i pubsub-js</code></pre>

<p>第二步：在需要的组件中引入<code>pubsub</code></p>
<pre class="language-none"><code class="language-none">import pubsub from &#39;pubsub-js&#39;</code></pre>

<p>第三步：利用<code>pubsub</code>发布（发送）数据</p>
<pre class="language-none"><code class="language-none">&lt;button @click&#x3D;&quot;sendMsg&quot;&gt;&lt;&#x2F;button&gt;</code></pre>
<pre class="language-none"><code class="language-none">methods: &#123;
    sendMsg()&#123;
        pubsub.publish(&#39;test&#39;,data)
    &#125;
&#125;</code></pre>

<p>第四步：利用<code>pubsub</code>订阅（接收）数据</p>
<pre class="language-none"><code class="language-none">mounted()&#123;
    this.pubId &#x3D; pubsub.subscribe(&#39;test&#39;,(msgName,data)&#x3D;&gt;&#123;
        console.log(&#39;有人发布了test消息&#39;,msgName,data)&#x2F;&#x2F;这里 msgName 就是 test
    &#125;)
&#125;,
beforeDestroy() &#123;
    pubsub.unsubscribe(this.pubId)
&#125;</code></pre>

<h1 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h1><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。</p>
<h2 id="过渡动画-单组件"><a href="#过渡动画-单组件" class="headerlink" title="过渡动画 - 单组件"></a>过渡动画 - 单组件</h2><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡</p>
<p>第一步：在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;</code></p>
<pre class="language-none"><code class="language-none">&lt;transition name&#x3D;&quot;fade&quot;&gt;
    &lt;p v-if&#x3D;&quot;show&quot;&gt;hello&lt;&#x2F;p&gt;
&lt;&#x2F;transition&gt;</code></pre>

<p>第二步：定义 class 样式</p>
<pre class="language-none"><code class="language-none">.fade-enter-active, .fade-leave-active &#123;
  transition: opacity .5s;
&#125;
.fade-enter, .fade-leave-to &#x2F;* .fade-leave-active below version 2.1.8 *&#x2F; &#123;
  opacity: 0;
&#125;</code></pre>

<h2 id="过渡动画-类名"><a href="#过渡动画-类名" class="headerlink" title="过渡动画 - 类名"></a>过渡动画 - 类名</h2><p>在进入&#x2F;离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡&#x2F;动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡&#x2F;动画完成之后移除。</li>
</ol>
<img src="/2021/10/30/Vue/transition.png" class="" title="Transition Diagram" loading="lazy">

<h2 id="过度动画-JS-钩子"><a href="#过度动画-JS-钩子" class="headerlink" title="过度动画 - JS 钩子"></a>过度动画 - JS 钩子</h2><p>可以在 attribute 中声明 JavaScript 钩子，通过 vue 提供给的动画钩子函数来<strong>绑定事件</strong>，然后在事件函数中处理对应的动画</p>
<p>入场动画：</p>
<blockquote>
<p>before-enter 动画入场运动前一刻执行</p>
<p>enter 动画运动时执行</p>
<p>after-enter 在动画 enter 函数中运行完毕并调用回调 done 时执行</p>
</blockquote>
<p>离场动画：（用法同上）</p>
<blockquote>
<p>before-leave</p>
<p>leave</p>
<p>after-leave</p>
</blockquote>
<p>例子：图片自跳动</p>
<pre class="language-none"><code class="language-none">&lt;transition appear name&#x3D;&quot;fade&quot; @after-enter&#x3D;&quot;show&#x3D;false&quot; @after-leave&#x3D;&quot;show&#x3D;true&quot;&gt;
    &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; v-if&#x3D;&quot;show&quot;&gt;
&lt;&#x2F;transition&gt;</code></pre>
<pre class="language-none"><code class="language-none">.fade-enter-active, .fade-leave-active &#123;
  transition:opacity 1s;
&#125;
.fade-enter, .fade-leave-to&#123;
  opacity:0;
&#125;</code></pre>

<p>添加 appear 属性后，网页才会一打开就有入场动画，否则需要触发</p>
<h2 id="过渡动画-多组件"><a href="#过渡动画-多组件" class="headerlink" title="过渡动画 - 多组件"></a>过渡动画 - 多组件</h2><p>多个组件的过渡简单很多 - 我们不需要使用 <code>key</code> attribute。相反，我们只需要使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6">动态组件</a>：</p>
<pre class="language-none"><code class="language-none">&lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;test&lt;&#x2F;button&gt;
&lt;transition-group name&#x3D;&quot;fade&quot;&gt;
    &lt;h1 v-show&#x3D;&quot;show&quot; key&#x3D;&quot;1&quot;&gt;TEST1&lt;&#x2F;h1&gt;
    &lt;h1 v-show&#x3D;&quot;!show&quot; key&#x3D;&quot;2&quot;&gt;TEST2&lt;&#x2F;h1&gt;
&lt;&#x2F;transition-group&gt;</code></pre>

<h2 id="过渡动画-第三方动画"><a href="#过渡动画-第三方动画" class="headerlink" title="过渡动画 - 第三方动画"></a>过渡动画 - 第三方动画</h2><p><a target="_blank" rel="noopener" href="https://animate.style/">Animate.css</a></p>
<pre class="language-none"><code class="language-none">&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;animate.css@3.5.1&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;

&lt;div id&#x3D;&quot;example-3&quot;&gt;
  &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;切换&lt;&#x2F;button&gt;
  &lt;transition
    name&#x3D;&quot;custom-classes-transition&quot;
    enter-active-class&#x3D;&quot;animated tada&quot;
    leave-active-class&#x3D;&quot;animated bounceOutRight&quot;
  &gt;
    &lt;p v-if&#x3D;&quot;show&quot;&gt;hello&lt;&#x2F;p&gt;
  &lt;&#x2F;transition&gt;
&lt;&#x2F;div&gt;</code></pre>

<h1 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h1><p>如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器，这个问题可以通过 <code>vue.config.js</code> 中的 <code>devServer.proxy</code> 选项来配置</p>
<h2 id="数据请求-Axios"><a href="#数据请求-Axios" class="headerlink" title="数据请求 - Axios"></a>数据请求 - Axios</h2><h2 id="数据请求-代理"><a href="#数据请求-代理" class="headerlink" title="数据请求 - 代理"></a>数据请求 - 代理</h2><p>在 <code>vue.config.js</code> 中添加如下配置</p>
<pre class="language-none"><code class="language-none">module.exports &#x3D; &#123;
  devServer: &#123;
    proxy: &#39;http:&#x2F;&#x2F;localhost:4000&#39;
  &#125;
&#125;</code></pre>

<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="Vuex-简介"><a href="#Vuex-简介" class="headerlink" title="Vuex - 简介"></a>Vuex - 简介</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用<strong>集中式存储</strong>管理应用的所有组件的状态，也是一种组件间通信的方式</p>
<h2 id="Vuex-使用"><a href="#Vuex-使用" class="headerlink" title="Vuex - 使用"></a>Vuex - 使用</h2><ol>
<li><p>安装<code>Vuex</code></p>
<pre class="language-none"><code class="language-none">npm install vuex</code></pre>
</li>
<li><p>创建文件<code>src/store/index.js</code></p>
</li>
</ol>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;引入
import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
&#x2F;&#x2F;应用
Vue.use(Vuex)
&#x2F;&#x2F;响应组件中的动作
const actions &#x3D; &#123;&#125;
&#x2F;&#x2F;操作数据
const state &#x3D; &#123;&#125;
&#x2F;&#x2F;存储数据
const mutations &#x3D; &#123;&#125;
&#x2F;&#x2F;创建并暴露store
export default new Vuex.Store(&#123;
  actions,
  mutations,
  state
&#125;)</code></pre>

<ol start="2">
<li>在<code>main.js</code>中配置</li>
</ol>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F;引入store
import store from &#39;.&#x2F;store&#39;
&#x2F;&#x2F;使用store
new Vue(&#123;
    store
&#125;)</code></pre>

<h2 id="Vuex-原理图"><a href="#Vuex-原理图" class="headerlink" title="Vuex - 原理图"></a>Vuex - 原理图</h2><img src="/2021/10/30/Vue/vuex.png" class="" title="vuex" loading="lazy">

<h2 id="Vuex-state"><a href="#Vuex-state" class="headerlink" title="Vuex - state"></a>Vuex - state</h2><p>Vue 管理的状态对象，存放数据的地方</p>
<p>注意：state 应该是唯一的</p>
<h2 id="Vuex-actions"><a href="#Vuex-actions" class="headerlink" title="Vuex - actions"></a>Vuex - actions</h2><ol>
<li><p>值为一个对象，包含多个响应用户动作的回调函数</p>
</li>
<li><p>通过 commit( )来触发 mutation 中函数的调用，间接更新 state</p>
</li>
<li><p>在组件中使用: $store.dispatch(‘对应的 action 回调名’) 触发回调</p>
</li>
<li><p><strong>可以包含异步代码</strong>（定时器, ajax 等等）</p>
</li>
</ol>
<h2 id="Vuex-mutations"><a href="#Vuex-mutations" class="headerlink" title="Vuex - mutations"></a>Vuex - mutations</h2><ol>
<li>值是一个对象，包含多个直接更新 state 的方法</li>
<li>在 action 中使用：commit(‘对应的 mutations 方法名’) 触发</li>
<li>mutations 中方法的特点：<strong>不能写异步代码、只能单纯的操作 state</strong></li>
</ol>
<h2 id="Vuex-getters"><a href="#Vuex-getters" class="headerlink" title="Vuex - getters"></a>Vuex - getters</h2><ol>
<li>值为一个对象，包含多个用于返回数据的函数，类似于计算属性</li>
<li>在组件中调用 $store.getters.xxx</li>
</ol>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由-简介"><a href="#路由-简介" class="headerlink" title="路由 - 简介"></a>路由 - 简介</h2><p>路由就是对应的映射关系，一组路由就是一组<code>key &lt;-&gt; value</code>键值对</p>
<p>key 就是路径</p>
<p>value 在前端中，是一个组件，当 key 改变时，会在页面上展示相应的 value 组件</p>
<p>value 在后端中，是一个函数，当 key 改变时，会处理客户端提交的请求</p>
<h2 id="路由-使用"><a href="#路由-使用" class="headerlink" title="路由 - 使用"></a>路由 - 使用</h2><ol>
<li>安装 vue-router ：<code>npm i vue-router</code></li>
<li>创建文件：<code>src/router/index.js</code></li>
<li>在<code>main.js</code>引入：<code>import VueRouter from &#39;vue-router&#39;</code></li>
<li>在<code>main.js</code>使用：<code>Vue.use(VueRouter)</code></li>
</ol>
<h2 id="路由-配置"><a href="#路由-配置" class="headerlink" title="路由 - 配置"></a>路由 - 配置</h2><pre class="language-none"><code class="language-none">import VueRouter from &#39;vue-router&#39;
&#x2F;&#x2F;引入组件
import Home from &#39;..&#x2F;views&#x2F;Home&#39;
&#x2F;&#x2F;创建并暴露一个路由
export default new VueRouter(&#123;
	routes: [
		&#123;
			name:&#39;Home&#39;,
			path:&#39;&#x2F;&#39;,
			component:Home
		&#125;,
	],
	mode: &#39;history&#39;
&#125;)</code></pre>

<h2 id="路由-嵌套"><a href="#路由-嵌套" class="headerlink" title="路由 - 嵌套"></a>路由 - 嵌套</h2><p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p>
<pre class="language-none"><code class="language-none">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts
+------------------+                  +-----------------+
| User             |                  | User            |
| +--------------+ |                  | +-------------+ |
| | Profile      | |  +------------&gt;  | | Posts       | |
| |              | |                  | |             | |
| +--------------+ |                  | +-------------+ |
+------------------+                  +-----------------+</code></pre>

<p>借助 <code>vue-router</code>，使用嵌套路由配置，就可以很简单地表达这种关系</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;&#x2F;user&#x2F;:id&#39;,
      component: User,
      children: [
        &#123;
          &#x2F;&#x2F; 当 &#x2F;user&#x2F;:id&#x2F;profile 匹配成功，
          &#x2F;&#x2F; UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;profile&#39;,
          component: UserProfile
        &#125;,
        &#123;
          &#x2F;&#x2F; 当 &#x2F;user&#x2F;:id&#x2F;posts 匹配成功
          &#x2F;&#x2F; UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中
          path: &#39;posts&#39;,
          component: UserPosts
        &#125;
      ]
    &#125;
  ]
&#125;)</code></pre>

<h2 id="路由-编程式导航"><a href="#路由-编程式导航" class="headerlink" title="路由 - 编程式导航"></a>路由 - 编程式导航</h2><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现</p>
<ol>
<li><code>router.push(location, onComplete?, onAbort?)</code></li>
</ol>
<p>在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例，因此你可以调用 <code>this.$router.push()</code>，可以跳转到指定的页面。当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code></p>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 字符串
router.push(&#39;home&#39;)

&#x2F;&#x2F; 对象
router.push(&#123; path: &#39;home&#39; &#125;)

&#x2F;&#x2F; 命名的路由
router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)

&#x2F;&#x2F; 带查询参数，变成 &#x2F;register?plan&#x3D;private
router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)</code></pre>

<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</strong></p>
<pre class="language-none"><code class="language-none">const userId &#x3D; &#39;123&#39;
router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123
router.push(&#123; path: &#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96; &#125;) &#x2F;&#x2F; -&gt; &#x2F;user&#x2F;123
&#x2F;&#x2F; 这里的 params 不生效
router.push(&#123; path: &#39;&#x2F;user&#39;, params: &#123; userId &#125;&#125;) &#x2F;&#x2F; -&gt; &#x2F;user</code></pre>

<ol start="2">
<li><p><code>router.replace(location, onComplete?, onAbort?)</code></p>
<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</p>
</li>
<li><p><code>router.go(n)</code></p>
<p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code></p>
<p>例子</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 在浏览器记录中前进一步，等同于 history.forward()
router.go(1)

&#x2F;&#x2F; 后退一步记录，等同于 history.back()
router.go(-1)

&#x2F;&#x2F; 前进 3 步记录
router.go(3)

&#x2F;&#x2F; 如果 history 记录不够用，那就默默地失败呗
router.go(-100)
router.go(100)</code></pre></li>
</ol>
<h2 id="路由-命名"><a href="#路由-命名" class="headerlink" title="路由 - 命名"></a>路由 - 命名</h2><p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;&#x2F;user&#x2F;:userId&#39;,
      name: &#39;user&#39;,
      component: User
    &#125;
  ]
&#125;)</code></pre>

<p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p>
<pre class="language-none"><code class="language-none">&lt;router-link :to&#x3D;&quot;&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;&#x2F;router-link&gt;</code></pre>

<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>
<pre class="language-none"><code class="language-none">router.push(&#123; name: &#39;user&#39;, params: &#123; userId: 123 &#125; &#125;)</code></pre>

<p>这两种方式都会把路由导航到 <code>/user/123</code> 路径</p>
<h2 id="路由-重定向"><a href="#路由-重定向" class="headerlink" title="路由 - 重定向"></a>路由 - 重定向</h2><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123; path: &#39;&#x2F;a&#39;, redirect: &#39;&#x2F;b&#39; &#125;
  ]
&#125;)</code></pre>

<p>重定向的目标也可以是一个命名的路由：</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123; path: &#39;&#x2F;a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;
  ]
&#125;)</code></pre>

<p>甚至是一个方法，动态返回重定向目标：</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123; path: &#39;&#x2F;a&#39;, redirect: to &#x3D;&gt; &#123;
      &#x2F;&#x2F; 方法接收 目标路由 作为参数
      &#x2F;&#x2F; return 重定向的 字符串路径&#x2F;路径对象
    &#125;&#125;
  ]
&#125;)</code></pre>

<h2 id="路由-别名"><a href="#路由-别名" class="headerlink" title="路由 - 别名"></a>路由 - 别名</h2><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢</p>
<p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样</strong></p>
<p>上面对应的路由配置为：</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123; path: &#39;&#x2F;a&#39;, component: A, alias: &#39;&#x2F;b&#39; &#125;
  ]
&#125;)</code></pre>

<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构</p>
<h2 id="路由-传参"><a href="#路由-传参" class="headerlink" title="路由 - 传参"></a>路由 - 传参</h2><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性</p>
<p>使用 <code>props</code> 将组件和路由解耦，如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性：</p>
<p><strong>取代与 <code>$route</code> 的耦合</strong></p>
<pre class="language-none"><code class="language-none">const User &#x3D; &#123;
  template: &#39;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;&#x2F;div&gt;&#39;
&#125;
const router &#x3D; new VueRouter(&#123;
  routes: [&#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User &#125;]
&#125;)</code></pre>

<p><strong>通过 <code>props</code> 解耦</strong></p>
<pre class="language-none"><code class="language-none">const User &#x3D; &#123;
  props: [&#39;id&#39;],
  template: &#39;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;&#x2F;div&gt;&#39;
&#125;
const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123; path: &#39;&#x2F;user&#x2F;:id&#39;, component: User, props: true &#125;,

    &#x2F;&#x2F; 对于包含命名视图的路由，你必须分别为每个命名视图添加 &#96;props&#96; 选项：
    &#123;
      path: &#39;&#x2F;user&#x2F;:id&#39;,
      components: &#123; default: User, sidebar: Sidebar &#125;,
      props: &#123; default: true, sidebar: false &#125;
    &#125;
  ]
&#125;)</code></pre>

<p>这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试</p>
<p>如果 <code>props</code> 是一个<strong>对象</strong>，它会被按原样设置为组件属性。当 <code>props</code> 是静态的时候有用</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;&#x2F;promotion&#x2F;from-newsletter&#39;,
      component: Promotion,
      props: &#123; newsletterPopup: false &#125;
    &#125;
  ]
&#125;)</code></pre>

<p>你可以创建一个<strong>函数</strong>返回 <code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;&#x2F;search&#39;,
      component: SearchUser,
      props: route &#x3D;&gt; (&#123; query: route.query.q &#125;)
    &#125;
  ]
&#125;)</code></pre>

<p>URL <code>/search?q=vue</code> 会将 <code>&#123;query: &#39;vue&#39;&#125;</code> 作为属性传递给 <code>SearchUser</code> 组件</p>
<h2 id="路由-history"><a href="#路由-history" class="headerlink" title="路由 - history"></a>路由 - history</h2><p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载</p>
<p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面</p>
<pre class="language-none"><code class="language-none">const router &#x3D; new VueRouter(&#123;
  mode: &#39;history&#39;,
  routes: [...]
&#125;)</code></pre>

<p>当你使用 history 模式时，URL 就像正常的 url，例如 <code>http://yoursite.com/user/id</code></p>
<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://oursite.com/user/id</code> 就会返回 404，这就不好看了</p>
<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">竟然有用？！赏！</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/images/Alipay.png"><img loading="lazy" src="/images/Alipay.png" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><span class="icon iconify" data-icon="ri:alipay-line"></span></span></div></div><div style="display:inline-block"><a href="/images/WechatPay.png"><img loading="lazy" src="/images/WechatPay.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><span class="icon iconify" data-icon="ri:wechat-pay-line"></span></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Nayst</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://www.nayst.top/2021/10/30/Vue/" title="Vue">https://www.nayst.top/2021/10/30/Vue/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/02/28/xss/" rel="prev" title="XSS"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">XSS</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/09/17/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="next" title="反序列化-PHP"><span class="post-nav-text">反序列化-PHP</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Nayst</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v6.2.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.6</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-07-01T18:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div><script src="https://fastly.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script>const images = [...document.querySelectorAll('.markdown-body img')]
mediumZoom(images)</script><style>.medium-zoom-image {
  z-index: 99;
}</style></body></html>